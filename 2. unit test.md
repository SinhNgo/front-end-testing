# Unit test
## 2.1 Unit test l√† g√¨?
- ƒê·ªãnh nghƒ©a: Unit test l√† qu√° tr√¨nh ki·ªÉm th·ª≠ t·ª´ng ph·∫ßn nh·ªè nh·∫•t c·ªßa code, th∆∞·ªùng l√† t·ª´ng function ho·∫∑c class/component.
- M·ª•c ƒë√≠ch:
  - ƒê·∫£m b·∫£o logic t·ª´ng ph·∫ßn nh·ªè nh·∫•t c·ªßa code ho·∫°t ƒë·ªông ƒë√∫ng nh∆∞ mong ƒë·ª£i.
  - Ph√°t hi·ªán l·ªói s·ªõm, gi√∫p gi·∫£m thi·ªÉu l·ªói ·ªü c√°c ph·∫ßn kh√°c c·ªßa h·ªá th·ªëng.
  - TƒÉng c∆∞·ªùng s·ª± t·ª± tin khi thay ƒë·ªïi code, gi√∫p d·ªÖ d√†ng refactor code m√† kh√¥ng lo l·ªói.

## 2.2 M·ªôt s·ªë nguy√™n t·∫Øc vi·∫øt unit test hi·ªáu qu·∫£
- C·∫•u tr√∫c c·ªßa 1 test case th∆∞·ªùng tu√¢n th·ªß theo m√¥ h√¨nh AAA:
  - **Arrange**: Chu·∫©n b·ªã d·ªØ li·ªáu c·∫ßn thi·∫øt cho test case.
  - **Act**: Th·ª±c thi h√†nh ƒë·ªông c·∫ßn ki·ªÉm th·ª≠.
  - **Assert**: So s√°nh k·∫øt qu·∫£ th·ª±c t·∫ø v·ªõi k·∫øt qu·∫£ mong ƒë·ª£i.

V√≠ d·ª•:

```ts
import { sum } from "../sum";

describe("sum function", () => {
  it("returns correct sum for positive numbers", () => {
    // Arrange
    const a = 2;
    const b = 3;
    const expected = 5;

    // Act
    const result = sum(2, 3);

    // Assert
    expect(result).toBe(5);
  });
});
```

- Quy t·∫Øc **FIRST** trong Unit Test:
  - **F**ast: Test case ph·∫£i ch·∫°y nhanh.
  - **I**ndependent: Test case ph·∫£i ch·∫°y ƒë·ªôc l·∫≠p.
  - **R**epeatable: Test case ph·∫£i ch·∫°y gi·ªëng nhau m·ªói l·∫ßn ch·∫°y.
  - **S**elf-validating: Test case ph·∫£i t·ª± ƒë√°nh gi√° k·∫øt qu·∫£.
  - **T**imely: Vi·∫øt ƒë√∫ng th·ªùi ƒëi·ªÉm, test case ƒë∆∞·ª£c vi·∫øt ra tr∆∞·ªõc khi vi·∫øt code.

**Vi ph·∫°m nguy√™n t·∫Øc Repeatable (C√≥ th·ªÉ l·∫∑p l·∫°i)**

üî¥ V√≠ d·ª• sai: Test n√†y ph·ª• thu·ªôc v√†o th·ªùi gian th·ª±c (`Date.now()`), m·ªói l·∫ßn ch·∫°y c√≥ th·ªÉ cho k·∫øt qu·∫£ kh√°c nhau.

```ts
test("should generate a unique order ID", () => {
  const orderId1 = `ORDER-${Date.now()}`;
  const orderId2 = `ORDER-${Date.now()}`;
  expect(orderId1).toBe(orderId2); // L·ªói v√¨ th·ªùi gian thay ƒë·ªïi
});
```
‚úÖ C√°ch vi·∫øt ƒë√∫ng: [Mock](#) Date.now() ƒë·ªÉ ƒë·∫£m b·∫£o test ch·∫°y l·∫°i v·∫´n cho k·∫øt qu·∫£ nh∆∞ nhau.

```ts
test("should generate a unique order ID", () => {
  const mockDateNow = jest.spyOn(Date, "now").mockReturnValue(0);
  const orderId1 = `ORDER-${Date.now()}`;
  const orderId2 = `ORDER-${Date.now()}`;
  expect(orderId1).toBe(orderId2); // Pass v√¨ Date.now() tr·∫£ v·ªÅ gi√° tr·ªã c·ªë ƒë·ªãnh
  mockDateNow.mockRestore();
});
```

**Vi ph·∫°m nguy√™n t·∫Øc Self-validating (T·ª± x√°c th·ª±c)**

üî¥ V√≠ d·ª• sai: Test n√†y kh√¥ng c√≥ b·∫•t k·ª≥ expect() n√†o ƒë·ªÉ x√°c th·ª±c k·∫øt qu·∫£, ch·ªâ log ra console.

```ts
test("should return correct user data", async () => {
  const user = await fetchUser(1);
  console.log(user); // Kh√¥ng c√≥ ki·ªÉm tra k·∫øt qu·∫£
});
```
‚úÖ C√°ch vi·∫øt ƒë√∫ng: S·ª≠ d·ª•ng expect() ƒë·ªÉ ki·ªÉm tra k·∫øt qu·∫£ tr·∫£ v·ªÅ.

```ts
test("should return correct user data", async () => {
  const user = await fetchUser(1);
  expect(user).toEqual({ id: 1, name: "Alice" });
});
```

## 2.3. C√°ch t·ªï ch·ª©c file test v√† c·∫•u tr√∫c m·ªôt file test
### 2.3.1. C√°ch t·ªï ch·ª©c file test
C√≥ kh√° nhi·ªÅu c√°ch t·ªï ch·ª©c file test kh√°c nhau, t√πy thu·ªôc v√†o framwork, c·∫•u tr√∫c d·ª± √°n, d∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë c√°ch t·ªï ch·ª©c ph·ªï bi·∫øn

- ƒê·∫∑t theo t√™n file source, c√πng th∆∞ m·ª•c v·ªõi file source theo c·∫•u tr√∫c:
  - `<file-goc>.test.ts`
  - `<file-goc>.spec.ts`

V√≠ d·ª•:

```
lib/
  services/
    userService.ts
    userService.test.ts
  sum.ts
  sum.test.ts
```

- ƒê·∫∑t trong th∆∞ m·ª•c `__tests__` ho·∫∑c `test`, v·ªõi c·∫•u tr√∫c th∆∞ m·ª•c t∆∞∆°ng t·ª± v·ªõi c√°c file source.

```
lib/
  __tests__/
    sum.test.ts
    services/
      userService.test.ts
  sum.ts
  services/
    userService.ts
```

- ƒê·∫∑t t√™n theo th∆∞ m·ª•c cha c·ªßa file source code.
```
lib/
  __tests__/
    sum.test.ts
  sum.ts
  services/
    __tests__/
      userService.test.ts
    userService.ts
```

### 2.3.2. C·∫•u tr√∫c m·ªôt file test
C·∫•u tr√∫c m·ªôt file test th∆∞·ªùng bao g·ªìm:
- Import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt.
- Import file c·∫ßn ki·ªÉm th·ª≠.
- Vi·∫øt c√°c test case.

1. H√†m `test()` v√† `it()`
- `test()` th∆∞·ªùng d√πng trong c√°ch c√°ch vi·∫øt truy·ªÅn th·ªëng.

V√≠ d·ª•:
```ts
test('adds two numbers correctly', () => {
  expect(1 + 2).toBe(3);
});
```

- `it()` c√°ch vi·∫øt t·∫≠p trung h∆°n v√†o h√†nh vi, th∆∞·ªùng d√πng trong c√°ch vi·∫øt BDD (Behavior-Driven Development).

V√≠ d·ª•:
```ts
it('should add two numbers correctly', () => {
  expect(1 + 2).toBe(3);
});
```

M√¥ t·∫£ b√™n trong `it` v√† `test` n√™n m√¥ t·∫£ r√µ h√†nh vi c·ªßa test case, s·ª≠ d·ª•ng ng√¥n ng·ªØ s√°t v·ªõi t·ª± nhi√™n nh·∫•t c√≥ th·ªÉ, kh√¥ng n√™n m√¥ t·∫£ c√°ch code ho·∫°t ƒë·ªông.

‚ùå Bad:
```ts
it('calls handleSubmit and sets state to loading')
it('handles input')
it('success')
it('displays a loading indicator when the form is submitted')
```

‚úÖ Good:
```ts
it('should submit the form and set the loading state') // M√¥ t·∫£ v·ªÅ h√†nh vi mong ƒë·ª£i thay v√¨ m√¥ t·∫£ chi ti·∫øt c√°ch code ho·∫°t ƒë·ªông
it('should display the user input')
it('should display a success message')
// D√πng describe() ƒë·ªÉ m√¥ t·∫£ tr∆∞∆°ng h·ª£p test, it ƒë·ªÉ m√¥ t·∫£ test case
discribe('when the form is submitted', () => {
  it('should display a loading indicator')
})
```

2. `describe()`: S·ª≠ d·ª•ng `describe()` ƒë·ªÉ nh√≥m c√°c test case li√™n quan l·∫°i v·ªõi nhau. `describe()` c√≥ th·ªÉ d√πng ƒë·ªÉ m√¥ t·∫£ cho m·ªôt h√†m, m·ªôt module, m·ªôt component, m·ªôt API, m·ªôt class, m·ªôt nh√≥m test case, m·ªôt tr∆∞·ªùng h·ª£p test. `describe()` c√≥ th·ªÉ ch·ª©a nhi·ªÅu `describe()` kh√°c b√™n trong.

  V√≠ d·ª•:

  ```ts
  // math.test.ts
  import Math from "../math";

  describe("Math", () => {
    describe("#sum", () => {
      test("returns correct sum for positive numbers", () => {
        expect(sum(2, 3)).toBe(5);
      });

      test("returns correct sum for negative numbers", () => {
        expect(sum(-2, -3)).toBe(-5);
      });

      test("returns correct sum for mixed numbers", () => {
        expect(sum(-2, 3)).toBe(1);
      });
    });
  });
  ```

  **üí° TIP:**
    - S·ª≠ d·ª•ng prefix `#` ƒë·ªÉ m√¥ t·∫£ c√°c **instance method** c·ªßa m·ªôt class ho·∫∑c **property** c·ªßa m·ªôt object.
    - S·ª≠ d·ª•ng prefix `.` ƒë·ªÉ m√¥ t·∫£ c√°c **static method** c·ªßa m·ªôt class ho·∫∑c **static property** c·ªßa m·ªôt object.

  V√≠ d·ª• 2:

  ```ts
  describe("Number", () => {
    describe("#toString()", () => {
      // C√°c test case li√™n quan ƒë·∫øn h√†m .toString()
    });

    describe("#toFixed()", () => {
      // C√°c test case li√™n quan ƒë·∫øn h√†m .toFixed()
    });

    describe(".parseInt", () => {
      // C√°c test case li√™n quan ƒë·∫øn h√†m Number.parseInt()
    });

    describe(".isNaN", () => {
      // C√°c test case li√™n quan ƒë·∫øn h√†m Number.isNaN()
    });

    describe(".MAX_VALUE", () => {
      // C√°c test case li√™n quan ƒë·∫øn static property Number.MAX_VALUE
    });
  });
  ```

3. **expect()**: k·∫øt h·ª£p v·ªõi c√°c matcher ƒë·ªÉ so s√°nh k·∫øt qu·∫£ th·ª±c t·∫ø v·ªõi k·∫øt qu·∫£ mong ƒë·ª£i.

V√≠ d·ª• m·ªôt s·ªë matcher ph·ªï bi·∫øn:

```ts
expect(1 + 4).toBe(5); // So s√°nh b·∫±ng
expect({ id: 1 }).toEqual({ id: 1 }); // So s√°nh deep equal
expect([1, 2, 3]).toContain(2); // Ki·ªÉm tra ph·∫ßn t·ª≠ c√≥ t·ªìn t·∫°i trong m·∫£ng
expect("hello").toMatch(/hello/); // Ki·ªÉm tra chu·ªói c√≥ match v·ªõi regex
expect(() => { throw new Error("error") }).toThrow("error"); // Ki·ªÉm tra h√†m c√≥ throw error
```

- C√°c matchers c·ªßa Jest: https://jestjs.io/docs/using-matchers
- Th∆∞ vi·ªán matchers ph·ªï bi·∫øn: https://www.chaijs.com

4. **beforeEach()** v√† **afterEach()**: D√πng ƒë·ªÉ ch·∫°y m·ªôt h√†m tr∆∞·ªõc m·ªói test case ho·∫∑c sau m·ªói test case.

```ts
let users = [];

// Reset users tr∆∞·ªõc m·ªói test case
beforeEach(() => {
  users = [{ id: 1, name: "Alice" }, { id: 2, name: "Bob" }];
});

it("should be able to add a new user", () => {
  users.push({ id: 3, name: "Charlie" });
  expect(users).toHaveLength(3);
});

it("should be able to remove a user", () => {
  users.pop();
  expect(users).toHaveLength(1);
});
```

5. **beforeAll()** v√† **afterAll()**: D√πng ƒë·ªÉ ch·∫°y m·ªôt h√†m tr∆∞·ªõc t·∫•t c·∫£ c√°c test case ho·∫∑c sau t·∫•t c·∫£ c√°c test case.

6. Mocking

X√©t t√¨nh hu·ªëng sau, b·∫°n c√≥ m·ªôt h√†m `registerUser()` c·∫ßn test. C√¥ng vi·ªác c·ªßa h√†m n√†y bao g·ªìm vi·ªác x√°c th·ª±c d·ªØ li·ªáu, insert d·ªØ li·ªáu v√†o database, g·ª≠i email x√°c nh·∫≠n,... B·∫°n s·∫Ω kh√¥ng mu·ªën trong qu√° tr√¨nh test h√†m n√†y li√™n t·ª•c g·ª≠i email x√°c nh·∫≠n, th·∫≠m ch√≠ l√† insert d·ªØ li·ªáu v√†o database. Ngo√†i ra, k·ªÉ c·∫£ khi b·∫°n kh√¥ng th·∫•y v·∫•n ƒë·ªÅ g√¨ v·ªõi vi·ªác nh·∫≠n email li√™n t·ª•c, vi·ªác g·ª≠i email trong qu√° tr√¨nh test s·∫Ω l√†m ch·∫≠m qu√° tr√¨nh ch·∫°y test c·ªßa b·∫°n, v√† b·∫°n c≈©ng kh√¥ng th·ªÉ test ƒë∆∞·ª£c tr∆∞·ªùng h·ª£p l·ªói khi email kh√¥ng g·ª≠i ƒë∆∞·ª£c.

ƒê·ªÉ gi·∫£i quy·∫øt nh·ªØng v·∫•n ƒë·ªÅ n√†y, b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng mock ƒë·ªÉ gi·∫£ l·∫≠p c√°c h√†m ph·ª• thu·ªôc, gi·∫£ l·∫≠p d·ªØ li·ªáu tr·∫£ v·ªÅ, gi·∫£ l·∫≠p h√†nh vi c·ªßa h√†m ph·ª• thu·ªôc.

> Mocking l√† k·ªπ thu·∫≠t gi·∫£ l·∫≠p m·ªôt h√†m ho·∫∑c module kh√°c ƒë·ªÉ ki·ªÉm th·ª≠ m√† kh√¥ng c·∫ßn ph·ª• thu·ªôc v√†o h√†m ho·∫∑c module th·∫≠t.

S·ª≠ d·ª•ng mock gi√∫p test nhanh h∆°n, kh√¥ng ph·ª• thu·ªôc v√†o c√°c h√†m ho·∫∑c module kh√°c, gi√∫p ki·ªÉm th·ª≠ c√°c tr∆∞·ªùng h·ª£p edge case m√† kh√≥ t√°i t·∫°o trong m√¥i tr∆∞·ªùng th·ª±c.

V√≠ d·ª• √°p d·ª•ng mock ƒë·ªÉ test function sau:

```ts
function handlePageLoad(productId) {
  return fetchProduct(productId)
    .then((data) => data.product)
    .catch(redirectToPageNotFound);
}
```

V·∫•n ƒë·ªÅ khi test function tr√™n l√† ph·ª• thu·ªôc v√†o h√†m `fetchProduct` v√† `redirectToPageNotFound`, ƒë·ªÉ test ƒë·ªß c√°c tr∆∞·ªùng h·ª£p c·∫ßn ph·∫£i mock 2 h√†m n√†y.

```ts
import { handlePageLoad } from "~/pages/Product.vue";

describe("ProductPage", () => {
  describe("when product is loaded", () => {
    it("should return product data", async () => {
      const product = { id: 1, name: "Product 1" };
      jest.spyOn(ProductPage.methods, "fetchProduct").mockResolvedValue({ product });

      const data = await ProductPage.handlePageLoad(1);

      expect(data).toEqual(product);
    });
  });

  describe("when product is not found", () => {
    it("should redirect to 404 page", async () => {
      jest.spyOn(ProductPage.methods, "fetchProduct").mockRejectedValue(new Error("Not found"));
      const redirectToPageNotFound = jest.fn();

      await ProductPage.handlePageLoad(1);

      expect(redirectToPageNotFound).toHaveBeenCalled();
    });
  });
});
```

Gi·∫£i th√≠ch:
- S·ª≠ d·ª•ng `jest.spyOn()` ƒë·ªÉ mock h√†m `fetchProduct` v√† `redirectToPageNotFound`.
- S·ª≠ d·ª•ng `mockResolvedValue()` ƒë·ªÉ gi·∫£ l·∫≠p h√†m tr·∫£ v·ªÅ gi√° tr·ªã mong mu·ªën.
- S·ª≠ d·ª•ng `mockRejectedValue()` ƒë·ªÉ gi·∫£ l·∫≠p h√†m tr·∫£ v·ªÅ l·ªói.
- S·ª≠ d·ª•ng `jest.fn()` ƒë·ªÉ t·∫°o m·ªôt mock function.

**üéØ Khi n√†o d√πng `jest.fn()` v√† `jest.spyOn()`?**
- D√πng jest.fn() (stub function) khi mu·ªën t·∫°o m·ªôt h√†m gi·∫£ l·∫≠p t·ª´ ƒë·∫ßu, ho√†n to√†n thay th·∫ø logic g·ªëc (th∆∞·ªùng d√πng ƒë·ªÉ mock API, database, ho·∫∑c callback).
- D√πng jest.spyOn() (spy function) khi mu·ªën theo d√µi m·ªôt h√†m c√≥ s·∫µn m√† kh√¥ng c·∫ßn thay ƒë·ªïi ho√†n to√†n logic (th∆∞·ªùng d√πng ƒë·ªÉ ki·ªÉm tra console, g·ªçi API, g·ªçi method c·ªßa class...), v·∫´n c√≥ th·ªÉ thay ƒë·ªïi gi√° tr·ªã tr·∫£ v·ªÅ b·∫±ng `mockResolvedValue()` ho·∫∑c `mockRejectedValue()` ho·∫∑c `mockReturnValue()`.

## 2.4. Integration test (Component test)

### 2.4.1. C√†i ƒë·∫∑t

ƒê·ªÉ c√†i ƒë·∫∑t Vitest v√†o m·ªôt d·ª± √°n c√≥ s·∫µn, ƒë·∫ßu ti√™n l√† c√†i ƒë·∫∑t vitest v√† c√°c dependencies c·∫ßn thi·∫øt:

```sh
npm install -D vitest happy-dom @testing-library/vue
```

Ho·∫∑c v·ªõi d·ª± √°n React

```sh
npm install -D vitest happy-dom @testing-library/react
```

C√≥ th·ªÉ s·ª≠ d·ª•ng happy-dom ho·∫∑c jest-dom, t√πy thu·ªôc v√†o y√™u c·∫ßu c·ªßa d·ª± √°n.

Ti·∫øp theo c√†i ƒë·∫∑t Vitest configuation

```ts
// vitest.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
  // ...
  test: {
    // enable jest-like global test APIs
    globals: true,
    // simulate DOM with happy-dom
    // (requires installing happy-dom as a peer dependency)
    environment: 'happy-dom'
  }
})
```

Tips: N·∫øu s·ª≠ d·ª•ng typescript, th√™m `vitest/globals` v√†o `types` trong `tsconfig.json` ƒë·ªÉ s·ª≠ d·ª•ng global test APIs.

```json
{
  "compilerOptions": {
    "types": ["vitest/globals"]
  }
}
```

C·∫≠p nh·∫≠t file `package.json` ƒë·ªÉ th√™m script test

```json
{
  "scripts": {
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest --coverage"
  }
}
```

Sau ƒë√≥ ch·∫°y test l·ªánh

```sh
npm run test
```

### 2.4.2. React component
- S·ª≠ d·ª•ng `@testing-library/react` ƒë·ªÉ test React component.

```ts
import {render, screen} from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom'
import Fetch from './fetch'

test('loads and displays greeting', async () => {
  // ARRANGE
  render(<Fetch url="/greeting" />)

  // ACT
  await userEvent.click(screen.getByText('Load Greeting'))
  await screen.findByRole('heading')

  // ASSERT
  expect(screen.getByRole('heading')).toHaveTextContent('hello there')
  expect(screen.getByRole('button')).toBeDisabled()
})
```

Cheatsheet: https://testing-library.com/docs/react-testing-library/cheatsheet

### 2.4.3. Vue component

- S·ª≠ d·ª•ng `@testing-library/vue` ƒë·ªÉ test Vue component.

V√≠ d·ª• test component Counter.vue:

```vue
<template>
  <div>
    <p>Times clicked: {{ count }}</p>
    <button @click="increment">increment</button>
  </div>
</template>

<script>
  export default {
    data: () => ({
      count: 0,
    }),

    methods: {
      increment() {
        this.count++
      },
    },
  }
</script>
```

```ts
import {render, fireEvent, screen} from '@testing-library/vue'
import Component from './Component.vue'

test('increments value on click', async () => {
  render(Component)

  // screen has all queries that you can use in your tests.
  // getByText returns the first matching node for the provided text, and
  // throws an error if no elements match or if more than one match is found.
  screen.getByText('Times clicked: 0')

  const button = screen.getByText('increment')

  // Dispatch a native click event to our button element.
  await fireEvent.click(button)
  await fireEvent.click(button)

  screen.getByText('Times clicked: 2')
})
```

V√≠ d·ª• test v-model

```vue
<template>
  <div>
    <p>Hi, my name is {{ user }}</p>

    <label for="username">Username:</label>
    <input v-model="user" id="username" name="username" />
  </div>
</template>

<script>
  export default {
    data: () => ({
      user: 'Alice',
    }),
  }
</script>
```

```ts
import {render, fireEvent, screen} from '@testing-library/vue'
import Component from './Component.vue'

test('properly handles v-model', async () => {
  render(Component)

  // Asserts initial state.
  screen.getByText('Hi, my name is Alice')

  // Get the input DOM node by querying the associated label.
  const usernameInput = screen.getByLabelText(/username/i)

  // Updates the <input> value and triggers an `input` event.
  // fireEvent.input() would make the test fail.
  await fireEvent.update(usernameInput, 'Bob')

  screen.getByText('Hi, my name is Bob')
})
```

Cheatsheet: https://testing-library.com/docs/vue-testing-library/cheatsheet

### 2.4.4. Best practices

- **Render the component**: S·ª≠ d·ª•ng `render()` ƒë·ªÉ render component c·∫ßn test. ƒê·ªëi v·ªõi Vue component, kh√¥ng n√™n s·ª≠ d·ª•ng `shallowMount`.
- Th√™m thu·ªôc t√≠nh `data-testid` v√†o c√°c element c·∫ßn test ƒë·ªÉ d·ªÖ d√†ng query.

## 2.5. Snapshot testing
### 2.5.1. üìå Snapshot testing l√† g√¨?

Snapshot Testing l√† m·ªôt k·ªπ thu·∫≠t ki·ªÉm th·ª≠ gi√∫p b·∫Øt gi·ªØ tr·∫°ng th√°i c·ªßa UI ho·∫∑c d·ªØ li·ªáu t·∫°i m·ªôt th·ªùi ƒëi·ªÉm c·ª• th·ªÉ v√† so s√°nh n√≥ v·ªõi c√°c l·∫ßn ch·∫°y test sau. N·∫øu snapshot thay ƒë·ªïi, test s·∫Ω th·∫•t b·∫°i, y√™u c·∫ßu x√°c nh·∫≠n xem thay ƒë·ªïi ƒë√≥ c√≥ h·ª£p l·ªá kh√¥ng.

### 2.5.2. üéØ Khi n√†o n√™n d√πng Snapshot Testing

‚úÖ Ki·ªÉm tra giao di·ªán component React/Vue ƒë·ªÉ ph√°t hi·ªán thay ƒë·ªïi kh√¥ng mong mu·ªën.
‚úÖ Ki·ªÉm th·ª≠ output c·ªßa m·ªôt h√†m tr·∫£ v·ªÅ chu·ªói JSON ho·∫∑c HTML.
‚úÖ Gi·ªØ tr·∫°ng th√°i ·ªïn ƒë·ªãnh cho c√°c c·∫•u tr√∫c d·ªØ li·ªáu ph·ª©c t·∫°p.
üö´ Kh√¥ng n√™n d√πng khi d·ªØ li·ªáu c√≥ th·ªÉ thay ƒë·ªïi theo th·ªùi gian (v√≠ d·ª•: ng√†y gi·ªù, ID ng·∫´u nhi√™n).

### 2.5.3. üìù C√°ch ho·∫°t ƒë·ªông c·ªßa Snapshot Testing

1. **T·∫°o snapshot**: L·∫ßn ch·∫°y ƒë·∫ßu ti√™n, snapshot s·∫Ω ƒë∆∞·ª£c t·∫°o ra v√† l∆∞u l·∫°i trong th∆∞ m·ª•c `__snapshots__`.
2. **So s√°nh snapshot**: M·ªói l·∫ßn ch·∫°y test sau, snapshot m·ªõi s·∫Ω ƒë∆∞·ª£c so s√°nh v·ªõi snapshot c≈©. N·∫øu c√≥ s·ª± thay ƒë·ªïi, test s·∫Ω fail.
3. **X√°c nh·∫≠n snapshot**: N·∫øu thay ƒë·ªïi l√† h·ª£p l·ªá, b·∫°n c√≥ th·ªÉ update snapshot b·∫±ng c√°ch ch·∫°y test v·ªõi option `--updateSnapshot`.

### 2.5.4. üìö C√°ch s·ª≠ d·ª•ng Snapshot Testing

1. **React**: S·ª≠ d·ª•ng `@testing-library/react` v√† `vitest` ƒë·ªÉ test React component.

```ts
import { render } from "@testing-library/react";
import { expect, it } from "vitest";
import App from "./App";

it("toUpperCase", () => {
  const { asFragment } = render(<App />);
  expect(asFragment()).toMatchSnapshot();
});
```

ƒêo·∫°n test tr√™n s·∫Ω render component `<App />` sau ƒë√≥ caputure output d∆∞·ªõi d·∫°ng snapshot. ·ªû l·∫ßn run test ƒë·∫ßu ti√™n, vitest s·∫Ω generate ra m·ªôt snapshot file ch∆∞a HTML ƒë√£ render. ·ªû c√°c l·∫ßn run test sau, vitest s·∫Ω so s√°nh snapshot m·ªõi v·ªõi snapshot c≈©.

2. **Vue**: S·ª≠ d·ª•ng `@testing-library/vue` ƒë·ªÉ test Vue component.

```ts
import { render } from "@testing-library/vue";
import { expect, it } from "vitest";
import App from "./App.vue";

it("toUpperCase", () => {
  const { baseElement } = render(App);
  expect(baseElement).toMatchSnapshot();
});
```

## 2.6. Code coverage
### 2.6.1. üìå Code Coverage l√† g√¨?
Code Coverage (ƒê·ªô ph·ªß m√£) l√† th∆∞·ªõc ƒëo cho bi·∫øt bao nhi√™u ph·∫ßn trƒÉm code c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ki·ªÉm tra b·∫±ng test. M·ª•c ti√™u c·ªßa code coverage l√† ƒë·∫£m b·∫£o r·∫±ng t·∫•t c·∫£ c√°c nh√°nh logic quan tr·ªçng trong code ƒë·ªÅu ƒë∆∞·ª£c ki·ªÉm th·ª≠.

### 2.6.2. üìä C√°c lo·∫°i Code Coverage ph·ªï bi·∫øn
1. **Statement coverage**: ƒêo l∆∞·ªùng s·ªë l∆∞·ª£ng c√¢u l·ªánh trong code ƒë√£ ƒë∆∞·ª£c th·ª±c thi.

V√≠ d·ª•:
```ts
function sum(a, b) {
  if (a > 0) {      // statement 1
    return a + b;   // statement 2
  }
  return b;         // statement 3
}
```

2. **Branch coverage**: ƒêo l∆∞·ªùng s·ªë l∆∞·ª£ng nh√°nh logic trong code ƒë√£ ƒë∆∞·ª£c th·ª±c thi. Bao g·ªìm:
   - **Branch**: M·ªôt nh√°nh logic l√† m·ªôt ƒëi·ªÅu ki·ªán ho·∫∑c l·ª±a ch·ªçn trong code.
   - **Decision point**: M·ªôt ƒëi·ªÉm quy·∫øt ƒë·ªãnh l√† m·ªôt ƒëi·ªÅu ki·ªán ho·∫∑c l·ª±a ch·ªçn trong code.

V√≠ d·ª•:

```ts
function sum(a, b) {
  if (a > 0) {      // Branch 1
    return a + b;   // Decision point 1
  }
  return b;         // Branch 2
}
```

3. **Function coverage**: ƒêo l∆∞·ªùng s·ªë l∆∞·ª£ng function trong code ƒë√£ ƒë∆∞·ª£c th·ª±c thi.

V√≠ d·ª•:

```ts
function sum(a, b) {        // Function 1
  return a + b;
}

function subtract(a, b) {   // Function 2
  return a - b;
}
```

4. **Line coverage**: ƒêo l∆∞·ªùng s·ªë l∆∞·ª£ng d√≤ng code ƒë√£ ƒë∆∞·ª£c th·ª±c thi.

V√≠ d·ª•:

```ts
function sum(a, b) {        // Line 1
  return a + b;            // Line 2
}
```

### 2.6.3. V√≠ d·ª• minh h·ªça

![alt text](./img/image.png)

![alt text](./img/image-1.png)

![alt text](./img/image-2.png)

### 2.6.4. üéØ Nh·ªØng l∆∞u √Ω quan tr·ªçng v·ªÅ Code Coverage
- ‚úÖ Code Coverage cao kh√¥ng ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng test t·ªët. Test c·∫ßn ki·ªÉm th·ª≠ c·∫£ logic, edge case, h√†nh vi ng∆∞·ªùi d√πng.
- ‚úÖ M·ª©c coverage khuy·∫øn ngh·ªã:
  - 80% tr·ªü l√™n cho unit test.
  - 60-70% cho integration test.
  - E2E test kh√¥ng c·∫ßn qu√° cao, quan tr·ªçng l√† m√¥ ph·ªèng ƒë√∫ng h√†nh vi ng∆∞·ªùi d√πng.
- ‚úÖ Kh√¥ng n√™n ch·∫°y theo 100% coverage ‚Üí Quan tr·ªçng nh·∫•t l√† ki·ªÉm th·ª≠ ƒë√∫ng logic, ch·ª© kh√¥ng ph·∫£i ch·ªâ ƒë·∫£m b·∫£o s·ªë li·ªáu.
