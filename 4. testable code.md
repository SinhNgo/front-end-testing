# Testable code
Để viết code dễ kiểm thử (testable), bạn cần áp dụng một số nguyên tắc và kỹ thuật lập trình. Dưới đây là một số hướng dẫn và ví dụ cụ thể:

## 1. Sử dụng Dependency Injection (DI)

Khi một class/module/function phụ thuộc vào một class/module/function khác (vd: API, DB, Logger,...) nếu không sử dụng DI sẽ rất khó để mock những phụ thuộc đó trong quá trình kiểm thử.

Ví dụ:

Không sử dụng DI:
```ts
class UserService {
  async getUser(userId: number) {
    const response = await fetch(`https://api.example.com/users/${userId}`);
    return response.json();
  }
}
```

Sử dụng DI:
```ts
class UserService {
  constructor(private apiClient: { get: (url: string) => Promise<any> }) {}

  async getUser(userId: number) {
    return this.apiClient.get(`/users/${userId}`);
  }
}
```

Unit test cho class `UserService`:

```ts
it("should return mock user", async () => {
  // Tạo mock API client
  const mockApiClient = {
    get: jest.fn().mockResolvedValue({ id: 1, name: "John Doe" }),
  };

  // Inject mock vào UserService
  const userService = new UserService(mockApiClient);
  const user = await userService.getUser(1);

  // Kiểm tra kết quả
  expect(user).toEqual({ id: 1, name: "John Doe" });
  expect(mockApiClient.get).toHaveBeenCalledWith("/users/1");
});
```
✔ Dễ dàng test mà không cần kết nối mạng.

✔ Không phụ thuộc vào API thật, giúp test nhanh hơn.

✔ Có thể thay đổi API client dễ dàng mà không cần sửa toàn bộ code.


Ví dụ 2:

```js
function displayMessage(message) {
  document.getElementById('message').innerText = message;
}
```

Sử dụng DI:

```js
function displayMessage(message, element) {
  element.innerText = message;
}

// Sử dụng
displayMessage('Hello', document.getElementById('message'));
```

## 2. Tách biệt nghiệp vụ và logic I/O

Hãy tách biệt logic xử lý nghiệp vụ và logic I/O (Input/Output). Điều này giúp bạn dễ dàng kiểm thử logic nghiệp vụ mà không cần phải quan tâm đến logic I/O.

Ví dụ:

Code không tách biệt:

Hàm `readConfigFile` phụ thuộc vào module `fs` gây khó khăn khi test vì phải tạo file thực tế.

```ts
const fs = require('fs');

function readConfigFile(filePath) {
  const data = fs.readFileSync(filePath, 'utf8');
  return JSON.parse(data);
}
```

Code dễ kiểm thử hơn:

```ts
function readConfigFile(fileService, filePath) {
  const data = fileService.readFileSync(filePath, 'utf8');
  return JSON.parse(data);
}

// Sử dụng
import * as fs from 'fs';
readConfigFile(fs, './config.json');
```

Unit test cho hàm `readConfigFile`:

```ts
it("should return config object", () => {
  const mockFileService = {
    readFileSync: jest.fn().mockReturnValue('{"key": "value"}'),
  };

  const config = readConfigFile(mockFileService, './config.json');

  expect(config).toEqual({ key: "value" });
  expect(mockFileService.readFileSync).toHaveBeenCalledWith('./config.json', 'utf8');
});
```

## 3. Sử dụng Pure Function

Pure function là hàm có đầu vào và đầu ra xác định, không phụ thuộc vào bất kỳ biến nào bên ngoài hàm (no side effects).

Ví dụ 1:

Code không "pure"
```ts
const taxRate = 0.1;

function calcFinalPrice(price) {
  return price + (1 + taxRate);
}
```

Code "pure"
```ts
function calcFinalPrice(price, taxRate = 0.1) {
  return price + (1 + taxRate);
}
```

Viết Unit Test dễ dàng hơn

```ts
it("should calculate correct price with tax", () => {
  expect(calcFinalPrice(100, 0.1)).toBe(110);
  expect(calcFinalPrice(100, 0.08)).toBe(108);
});
```

Ví dụ 2:

Code không "pure" (thay đổi trạng thái bên ngoài hàm)

```ts
let counter = 0;

function increment() {
  counter++;
}
```

**🔥 Vấn đề:**

❌ Hàm thay đổi giá trị counter, làm kết quả khác nhau mỗi lần chạy.

❌ Test phải reset counter trước mỗi lần chạy, rất dễ gặp lỗi.

Code "pure" (không thay đổi trạng thái bên ngoài hàm)

```ts
function increment(counter) {
  return counter + 1;
}
```

Viết Unit Test dễ dàng hơn

```ts
test("increment should return incremented value", () => {
  expect(increment(0)).toBe(1);
  expect(increment(5)).toBe(6);
});
```

## 4. Tách biệt concerns

Hãy phân chia logic thành các phần nhỏ, mỗi phần giải quyết một vấn đề cụ thể (Single Responsibility Principle). Điều này giúp bạn dễ dàng kiểm thử từng phần một mà không ảnh hưởng đến các phần khác.

Ví dụ:

Code không tách biệt concerns:

```ts
function sendEmail(user) {
  const email = user.email;
  const message = `Hello, ${user.name}`;
  // Gửi email
}
```

Code tách biệt concerns:

```ts
function getEmailContent(user) {
  return `Hello, ${user.name}`;
}

function sendEmail(email, message) {
  // Gửi email
}
```

Ví dụ 2:

Code không tách biệt concerns:

```ts
function fetchDataAndDisplay() {
  const data = fetchData();
  displayData(data);
}
```

Code tách biệt concerns:

```ts
function fetchData() {
  return fetch('https://api.example.com/data');
}

function displayData(data) {
  // Hiển thị dữ liệu
}

// Sử dụng
function main() {
  const data = fetchData();
  displayData(data);
}
```

Ví dụ 2:

Code viết gộp:

```ts
import fs from "fs";

function processConfig() {
  const data = fs.readFileSync("config.json", "utf-8");
  const config = JSON.parse(data);

  console.log(`App Name: ${config.appName}`);
}
```

Code tách biệt concerns:

```ts
function readFile(fileReader: { readFileSync: (path: string, encoding: string) => string }, path: string) {
  return fileReader.readFileSync(path, "utf-8");
}

function parseConfig(jsonString: string) {
  return JSON.parse(jsonString);
}

function displayConfig(config: { appName: string }) {
  console.log(`App Name: ${config.appName}`);
}

// Sử dụng
const fileReader = { readFileSync: fs.readFileSync };
const configData = readFile(fileReader, "config.json");
const config = parseConfig(configData);
displayConfig(config);
```
